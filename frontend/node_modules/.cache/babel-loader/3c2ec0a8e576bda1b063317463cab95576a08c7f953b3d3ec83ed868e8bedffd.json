{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\nimport { ListContext } from '../useList';\n\n/**\n * Stabilizes the ListContext value for the Option component, so it doesn't change when sibling Options update.\n *\n * @param value The value of the Option.\n * @returns The stable ListContext value.\n *\n * Demos:\n *\n * - [Select](https://mui.com/base-ui/react-select/#hooks)\n *\n * API:\n *\n * - [useOptionContextStabilizer API](https://mui.com/base-ui/react-select/hooks-api/#use-option-context-stabilizer)\n */\nexport function useOptionContextStabilizer(value) {\n  var listContext = React.useContext(ListContext);\n  if (!listContext) {\n    throw new Error('Option: ListContext was not found.');\n  }\n  var getItemState = listContext.getItemState,\n    dispatch = listContext.dispatch;\n  var _getItemState = getItemState(value),\n    highlighted = _getItemState.highlighted,\n    selected = _getItemState.selected,\n    focusable = _getItemState.focusable;\n\n  // The local version of getItemState can be only called with the current Option's value.\n  // It doesn't make much sense to render an Option depending on other Options' state anyway.\n  var localGetItemState = React.useCallback(function (itemValue) {\n    if (itemValue !== value) {\n      throw new Error(['Base UI Option: Tried to access the state of another Option.', 'This is unsupported when the Option uses the OptionContextStabilizer as a performance optimization.'].join('/n'));\n    }\n    return {\n      highlighted: highlighted,\n      selected: selected,\n      focusable: focusable\n    };\n  }, [highlighted, selected, focusable, value]);\n\n  // Create a local (per Option) instance of the ListContext that changes only when\n  // the getItemState's return value changes.\n  // This makes Options re-render only when their state actually change, not when any Option's state changes.\n  var localContextValue = React.useMemo(function () {\n    return {\n      dispatch: dispatch,\n      getItemState: localGetItemState\n    };\n  }, [dispatch, localGetItemState]);\n  return {\n    contextValue: localContextValue\n  };\n}","map":{"version":3,"names":["React","ListContext","useOptionContextStabilizer","value","listContext","useContext","Error","getItemState","dispatch","_getItemState","highlighted","selected","focusable","localGetItemState","useCallback","itemValue","join","localContextValue","useMemo","contextValue"],"sources":["/var/www/html/React/lkgs/node_modules/@mui/base/useOption/useOptionContextStabilizer.js"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { ListContext } from '../useList';\n\n/**\n * Stabilizes the ListContext value for the Option component, so it doesn't change when sibling Options update.\n *\n * @param value The value of the Option.\n * @returns The stable ListContext value.\n *\n * Demos:\n *\n * - [Select](https://mui.com/base-ui/react-select/#hooks)\n *\n * API:\n *\n * - [useOptionContextStabilizer API](https://mui.com/base-ui/react-select/hooks-api/#use-option-context-stabilizer)\n */\nexport function useOptionContextStabilizer(value) {\n  const listContext = React.useContext(ListContext);\n  if (!listContext) {\n    throw new Error('Option: ListContext was not found.');\n  }\n  const {\n    getItemState,\n    dispatch\n  } = listContext;\n  const {\n    highlighted,\n    selected,\n    focusable\n  } = getItemState(value);\n\n  // The local version of getItemState can be only called with the current Option's value.\n  // It doesn't make much sense to render an Option depending on other Options' state anyway.\n  const localGetItemState = React.useCallback(itemValue => {\n    if (itemValue !== value) {\n      throw new Error(['Base UI Option: Tried to access the state of another Option.', 'This is unsupported when the Option uses the OptionContextStabilizer as a performance optimization.'].join('/n'));\n    }\n    return {\n      highlighted,\n      selected,\n      focusable\n    };\n  }, [highlighted, selected, focusable, value]);\n\n  // Create a local (per Option) instance of the ListContext that changes only when\n  // the getItemState's return value changes.\n  // This makes Options re-render only when their state actually change, not when any Option's state changes.\n  const localContextValue = React.useMemo(() => ({\n    dispatch,\n    getItemState: localGetItemState\n  }), [dispatch, localGetItemState]);\n  return {\n    contextValue: localContextValue\n  };\n}"],"mappings":"AAAA,YAAY;;AAEZ,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,WAAW,QAAQ,YAAY;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,0BAA0BA,CAACC,KAAK,EAAE;EAChD,IAAMC,WAAW,GAAGJ,KAAK,CAACK,UAAU,CAACJ,WAAW,CAAC;EACjD,IAAI,CAACG,WAAW,EAAE;IAChB,MAAM,IAAIE,KAAK,CAAC,oCAAoC,CAAC;EACvD;EACA,IACEC,YAAY,GAEVH,WAAW,CAFbG,YAAY;IACZC,QAAQ,GACNJ,WAAW,CADbI,QAAQ;EAEV,IAAAC,aAAA,GAIIF,YAAY,CAACJ,KAAK,CAAC;IAHrBO,WAAW,GAAAD,aAAA,CAAXC,WAAW;IACXC,QAAQ,GAAAF,aAAA,CAARE,QAAQ;IACRC,SAAS,GAAAH,aAAA,CAATG,SAAS;;EAGX;EACA;EACA,IAAMC,iBAAiB,GAAGb,KAAK,CAACc,WAAW,CAAC,UAAAC,SAAS,EAAI;IACvD,IAAIA,SAAS,KAAKZ,KAAK,EAAE;MACvB,MAAM,IAAIG,KAAK,CAAC,CAAC,8DAA8D,EAAE,qGAAqG,CAAC,CAACU,IAAI,CAAC,IAAI,CAAC,CAAC;IACrM;IACA,OAAO;MACLN,WAAW,EAAXA,WAAW;MACXC,QAAQ,EAARA,QAAQ;MACRC,SAAS,EAATA;IACF,CAAC;EACH,CAAC,EAAE,CAACF,WAAW,EAAEC,QAAQ,EAAEC,SAAS,EAAET,KAAK,CAAC,CAAC;;EAE7C;EACA;EACA;EACA,IAAMc,iBAAiB,GAAGjB,KAAK,CAACkB,OAAO,CAAC;IAAA,OAAO;MAC7CV,QAAQ,EAARA,QAAQ;MACRD,YAAY,EAAEM;IAChB,CAAC;EAAA,CAAC,EAAE,CAACL,QAAQ,EAAEK,iBAAiB,CAAC,CAAC;EAClC,OAAO;IACLM,YAAY,EAAEF;EAChB,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}